1:1-1:1::Main.$trModule :: "GHC.Types.Module"
30:1-30:6::Main.litsC :: "x1:[GHC.Types.Int] -> {VV : (Data.Set.Internal.Set GHC.Types.Int) | VV == litsC x1}"
30:12-30:19::_ :: "{VV : forall a .\n      {v : (Data.Set.Internal.Set a) | Set_emp v} | VV == empty}"
31:18-31:26::lq_anf$##7205759403792805723 :: "{v : (Data.Set.Internal.Set GHC.Types.Int) | v == litsC cs}"
31:24-31:26::cs :: "{v : [GHC.Types.Int] | v == cs\n                       && len v >= 0}"
31:37-31:50::lq_anf$##7205759403792805724 :: "{v : (Data.Set.Internal.Set GHC.Types.Int) | v == Set_sng l}"
31:49-31:50::l :: "{v : GHC.Types.Int | v == l}"
38:1-38:6::Main.litsF :: "x1:[[GHC.Types.Int]] -> {VV : (Data.Set.Internal.Set GHC.Types.Int) | VV == litsF x1}"
38:12-38:19::_ :: "{VV : forall a .\n      {v : (Data.Set.Internal.Set a) | Set_emp v} | VV == empty}"
39:18-39:26::lq_anf$##7205759403792805726 :: "{v : (Data.Set.Internal.Set GHC.Types.Int) | v == litsF ls}"
39:24-39:26::ls :: "{v : [[GHC.Types.Int]] | v == ls\n                         && len v >= 0}"
39:37-39:44::lq_anf$##7205759403792805727 :: "{v : (Data.Set.Internal.Set GHC.Types.Int) | v == litsC c}"
39:43-39:44::c :: "{v : [GHC.Types.Int] | v == c\n                       && len v >= 0}"
43:1-43:5:::Main.main :: "(GHC.Types.IO ())"
43:15-43:17::GHC.Tuple.() :: "{v : () | v == ()}"
47:1-47:9::Main.solveSAT :: "[[GHC.Types.Int]] -> (GHC.Maybe.Maybe [GHC.Types.Int])"
47:10-47:17::formula :: "[[GHC.Types.Int]]"
47:29-47:36::formula :: "{v : [[GHC.Types.Int]] | v == formula\n                         && len v >= 0}"
47:37-47:39::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | Set_emp (listElts v)\n                                                  && len v == 0\n                                                  && litsC v == Set_empty 0\n                                                  && litsF v == Set_empty 0} | VV == []}"
51:1-51:9::Main.getModel :: "[[GHC.Types.Int]] -> [GHC.Types.Int] -> (GHC.Maybe.Maybe [GHC.Types.Int])"
51:13-51:18::model :: "[GHC.Types.Int]"
51:21-51:31::GHC.Maybe.Just :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1\n                                         && lqdc##$select v == x1} | VV == Just}"
51:26-51:31::model :: "{v : [GHC.Types.Int] | v == model\n                       && len v >= 0}"
53:5-53:21::lq_anf$##7205759403792805753 :: "GHC.Types.Bool"
53:9-53:13::_ :: "forall a .\nv:[a] -> {v' : GHC.Types.Bool | (v' <=> len v == 0)\n                                && (not v' <=> len v > 0)}"
53:14-53:21::ds_d32n :: "{v : [[GHC.Types.Int]] | len v >= 0}"
53:24-53:31::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
54:5-54:29::lq_anf$##7205759403792805758 :: "GHC.Types.Bool"
54:9-54:21::lq_anf$##7205759403792805757 :: "[GHC.Types.Int] -> GHC.Types.Bool"
54:10-54:14::_ :: "forall a .\nv:[a] -> {v' : GHC.Types.Bool | (v' <=> len v == 0)\n                                && (not v' <=> len v > 0)}"
54:17-54:20::lq_anf$##7205759403792805756 :: "[GHC.Types.Int] -> [GHC.Types.Int]"
54:22-54:29::ds_d32n :: "{v : [[GHC.Types.Int]] | len v >= 0}"
54:32-54:39::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
55:22-55:43::lq_anf$##7205759403792805760 :: "(GHC.Maybe.Maybe (GHC.Types.Int, [[GHC.Types.Int]]))"
55:36-55:43::ds_d32n :: "{v : [[GHC.Types.Int]] | len v >= 0}"
56:33-56:68::Main.getModel :: "[[GHC.Types.Int]] -> [GHC.Types.Int] -> (GHC.Maybe.Maybe [GHC.Types.Int])"
56:42-56:56::updatedFormula :: "{v : [[GHC.Types.Int]] | v == updatedFormula\n                         && len v >= 0}"
56:57-56:68::lq_anf$##7205759403792805777 :: "{v : [GHC.Types.Int] | head v == l\n                       && len v == 1 + len model\n                       && listElts v == Set_cup (Set_sng l) (listElts model)\n                       && litsC v == Set_cup (litsC model) (Set_sng l)\n                       && litsF v == Set_cup (litsF model) (litsC l)\n                       && tail v == model}"
56:58-56:59::l :: "{v : GHC.Types.Int | v == l}"
56:62-56:67::model :: "{v : [GHC.Types.Int] | v == model\n                       && len v >= 0}"
57:21-57:46::lq_anf$##7205759403792805762 :: "(GHC.Maybe.Maybe (GHC.Types.Int, [[GHC.Types.Int]]))"
57:39-57:46::ds_d32n :: "{v : [[GHC.Types.Int]] | len v >= 0}"
58:35-58:70::Main.getModel :: "[[GHC.Types.Int]] -> [GHC.Types.Int] -> (GHC.Maybe.Maybe [GHC.Types.Int])"
58:44-58:58::updatedFormula :: "{v : [[GHC.Types.Int]] | v == updatedFormula\n                         && len v >= 0}"
58:59-58:70::lq_anf$##7205759403792805775 :: "{v : [GHC.Types.Int] | head v == l\n                       && len v == 1 + len model\n                       && listElts v == Set_cup (Set_sng l) (listElts model)\n                       && litsC v == Set_cup (litsC model) (Set_sng l)\n                       && litsF v == Set_cup (litsF model) (litsC l)\n                       && tail v == model}"
58:60-58:61::l :: "{v : GHC.Types.Int | v == l}"
58:64-58:69::model :: "{v : [GHC.Types.Int] | v == model\n                       && len v >= 0}"
59:23-59:44::lq_anf$##7205759403792805764 :: "(GHC.Maybe.Maybe GHC.Types.Int)"
59:37-59:44::ds_d32n :: "{v : [[GHC.Types.Int]] | len v >= 0}"
61:16-61:58::lq_anf$##7205759403792805768 :: "(GHC.Maybe.Maybe [GHC.Types.Int])"
61:25-61:46::lq_anf$##7205759403792805766 :: "[[GHC.Types.Int]]"
61:36-61:37::l :: "{v : GHC.Types.Int | v == l}"
61:38-61:45::ds_d32n :: "{v : [[GHC.Types.Int]] | len v >= 0}"
61:47-61:58::lq_anf$##7205759403792805767 :: "{v : [GHC.Types.Int] | head v == l\n                       && len v == 1 + len model\n                       && listElts v == Set_cup (Set_sng l) (listElts model)\n                       && litsC v == Set_cup (litsC model) (Set_sng l)\n                       && litsF v == Set_cup (litsF model) (litsC l)\n                       && tail v == model}"
61:48-61:49::l :: "{v : GHC.Types.Int | v == l}"
61:52-61:57::model :: "{v : [GHC.Types.Int] | v == model\n                       && len v >= 0}"
62:33-62:49::GHC.Maybe.Just :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1\n                                         && lqdc##$select v == x1} | VV == Just}"
62:38-62:49::resultModel :: "{v : [GHC.Types.Int] | v == resultModel\n                       && len v >= 0}"
63:24-63:70::Main.getModel :: "[[GHC.Types.Int]] -> [GHC.Types.Int] -> (GHC.Maybe.Maybe [GHC.Types.Int])"
63:33-63:57::lq_anf$##7205759403792805771 :: "[[GHC.Types.Int]]"
63:44-63:48::lq_anf$##7205759403792805770 :: "{v : GHC.Types.Int | v == (-l)}"
63:46-63:47::l :: "{v : GHC.Types.Int | v == l}"
63:49-63:56::ds_d32n :: "{v : [[GHC.Types.Int]] | len v >= 0}"
63:58-63:70::lq_anf$##7205759403792805773 :: "{v : [GHC.Types.Int] | len v == 1 + len model\n                       && tail v == model}"
63:59-63:61::lq_anf$##7205759403792805772 :: "{v : GHC.Types.Int | v == (-l)}"
63:60-63:61::l :: "{v : GHC.Types.Int | v == l}"
63:64-63:69::model :: "{v : [GHC.Types.Int] | v == model\n                       && len v >= 0}"
64:20-64:27::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
68:1-68:14::Main.unitPropagate :: "[[GHC.Types.Int]] -> (GHC.Maybe.Maybe (GHC.Types.Int, [[GHC.Types.Int]]))"
68:15-68:22::formula :: "[[GHC.Types.Int]]"
69:8-69:54::lq_anf$##7205759403792805743 :: "{v : [[GHC.Types.Int]] | len v <= len formula}"
69:15-69:46::GHC.Classes.$fEqInt :: "{v : (GHC.Classes.Eq GHC.Types.Int) | v == $fEqInt}"
69:17-69:23::clause :: "[GHC.Types.Int]"
69:27-69:40::lq_anf$##7205759403792805739 :: "{v : GHC.Types.Int | v == len clause\n                     && v >= 0}"
69:34-69:40::clause :: "{v : [GHC.Types.Int] | v == clause\n                       && len v >= 0}"
69:44-69:45::lq_anf$##7205759403792805741 :: "GHC.Types.Int"
69:47-69:54::formula :: "{v : [[GHC.Types.Int]] | v == formula\n                         && len v >= 0}"
70:22-70:67::GHC.Maybe.Just :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1\n                                         && lqdc##$select v == x1} | VV == Just}"
70:27-70:67::lq_anf$##7205759403792805748 :: "{v : (GHC.Types.Int, [[GHC.Types.Int]]) | fst v == unitLit\n                                          && x_Tuple21 v == unitLit}"
70:28-70:35::unitLit :: "{v : GHC.Types.Int | v == unitLit}"
70:37-70:66::lq_anf$##7205759403792805747 :: "[[GHC.Types.Int]]"
70:51-70:58::unitLit :: "{v : GHC.Types.Int | v == unitLit}"
70:59-70:66::formula :: "{v : [[GHC.Types.Int]] | v == formula\n                         && len v >= 0}"
71:10-71:17::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
75:1-75:18::Main.pureLiteralAssign :: "[[GHC.Types.Int]] -> (GHC.Maybe.Maybe (GHC.Types.Int, [[GHC.Types.Int]]))"
75:19-75:26::formula :: "[[GHC.Types.Int]]"
76:8-76:11::_ :: "[GHC.Types.Int] -> [GHC.Types.Int]"
76:14-76:28::lq_anf$##7205759403792805734 :: "[GHC.Types.Int]"
76:21-76:28::formula :: "{v : [[GHC.Types.Int]] | v == formula\n                         && len v >= 0}"
77:11-77:18::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
78:20-78:74::GHC.Maybe.Just :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1\n                                         && lqdc##$select v == x1} | VV == Just}"
78:25-78:74::lq_anf$##7205759403792805738 :: "{v : (GHC.Types.Int, [[GHC.Types.Int]]) | fst v == literal\n                                          && x_Tuple21 v == literal}"
78:26-78:33::literal :: "{v : GHC.Types.Int | v == literal}"
78:35-78:73::lq_anf$##7205759403792805737 :: "[[GHC.Types.Int]]"
78:58-78:65::literal :: "{v : GHC.Types.Int | v == literal}"
78:66-78:73::formula :: "{v : [[GHC.Types.Int]] | v == formula\n                         && len v >= 0}"
82:1-82:14::Main.chooseLiteral :: "[[GHC.Types.Int]] -> (GHC.Maybe.Maybe GHC.Types.Int)"
82:15-82:22::formula :: "[[GHC.Types.Int]]"
83:8-83:22::lq_anf$##7205759403792805728 :: "[GHC.Types.Int]"
83:15-83:22::formula :: "{v : [[GHC.Types.Int]] | v == formula\n                         && len v >= 0}"
84:11-84:18::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | not (isJust v)} | VV == Nothing}"
85:20-85:32::GHC.Maybe.Just :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | isJust v\n                                         && fromJust v == x1\n                                         && lqdc##$select v == x1} | VV == Just}"
85:25-85:32::literal :: "{v : GHC.Types.Int | v == literal}"
95:1-95:15::Main.chooseLiteral' :: "x1:{VV : [[GHC.Types.Int]] | litsF VV /= Set_empty 0} -> {VV : GHC.Types.Int | Set_mem VV (litsF x1)}"
95:28-95:45::Main.chooseLiteral' :: "x1:{VV : [[GHC.Types.Int]] | litsF VV /= Set_empty 0} -> {VV : GHC.Types.Int | Set_mem VV (litsF x1)}"
95:43-95:45::cs :: "{v : [[GHC.Types.Int]] | v == cs\n                         && len v >= 0}"
96:33-96:34::l :: "{v : GHC.Types.Int | v == l}"
97:20-97:52::Main.die :: "{VV : forall a . {v : [GHC.Types.Char] | False} -> a | VV == die}"
97:24-97:52::lq_anf$##7205759403792805716 :: "[GHC.Types.Char]"
101:1-101:10::Main.propagate :: "GHC.Types.Int -> [[GHC.Types.Int]] -> [[GHC.Types.Int]]"
101:11-101:18::literal :: "GHC.Types.Int"
101:44-101:55::lq_anf$##7205759403792805732 :: "{v : GHC.Types.Int | v == (-literal)}"
101:47-101:54::literal :: "{v : GHC.Types.Int | v == literal}"
105:1-105:14::Main.removeLiteral :: "GHC.Types.Int -> [[GHC.Types.Int]] -> [[GHC.Types.Int]]"
105:15-105:22::literal :: "GHC.Types.Int"
105:32-105:49::lq_anf$##7205759403792805733 :: "[GHC.Types.Int] -> GHC.Types.Bool"
105:41-105:48::literal :: "{v : GHC.Types.Int | v == literal}"
110:1-110:23::Main.removeLiteralInstances :: "GHC.Types.Int -> [[GHC.Types.Int]] -> [[GHC.Types.Int]]"
110:24-110:31::literal :: "GHC.Types.Int"
110:38-110:59::lq_anf$##7205759403792805731 :: "x1:[GHC.Types.Int] -> {v : [GHC.Types.Int] | len v <= len x1}"
110:46-110:58::_ :: "GHC.Types.Bool"
110:50-110:57::literal :: "{v : GHC.Types.Int | v == literal}"
114:1-114:4::Main.die :: "forall a . {VV : [GHC.Types.Char] | False} -> a"